we’re building a background that reacts to any image. the goal is to make it feel like the image is bleeding its colors softly into the environment — a glowing, blurry, moving mist that always matches the image’s palette. the image can be anything. the background should automatically generate from it.

we start simple: one image, one background layer.

<div class="image-wrapper">
  <div class="bg"></div>
  <img id="main-img" src="yourimage.jpg" alt="">
</div>


the .bg div sits behind the image and fills the whole container. it’s going to be the moving color field. css handles blur and animation.

.image-wrapper {
  position: relative;
  width: 100%;
  height: 100vh;
  overflow: hidden;
}

.bg {
  position: absolute;
  top: 0; left: 0;
  width: 100%;
  height: 100%;
  filter: blur(60px);
  background-size: 400% 400%;
  animation: moveGradient 15s ease-in-out infinite alternate;
  transition: background 1s ease;
}

@keyframes moveGradient {
  0% { background-position: 0% 0%; }
  50% { background-position: 100% 100%; }
  100% { background-position: 0% 0%; }
}

#main-img {
  width: 100%;
  height: auto;
  position: relative;
  z-index: 2;
}


now the javascript part. once the image is loaded, we extract its main colors using something like color thief. those colors become a smooth gradient that animates behind it.

const img = document.getElementById('main-img');
const bg = document.querySelector('.bg');

img.onload = () => {
  const colorThief = new ColorThief();
  const palette = colorThief.getPalette(img, 5);
  const gradient = `linear-gradient(270deg,
    rgb(${palette[0]}),
    rgb(${palette[1]}),
    rgb(${palette[2]}),
    rgb(${palette[3]}))`;
  bg.style.background = gradient;
};


this already gives a soft blur that moves slowly. but we can take it further. if you want the blur to feel alive — like liquid or smoke — we can use a webgl canvas or shader-based animation instead of a simple css gradient. for example, we can render the extracted colors as flowing blobs with fragment shaders, using something like regl, pixi.js, or three.js.

here’s a conceptual idea for that:

// pseudo setup for a webgl blur background
const canvas = document.createElement('canvas');
document.body.appendChild(canvas);
const gl = canvas.getContext('webgl');
initShader(gl, `
  precision mediump float;
  uniform float time;
  void main() {
    vec2 uv = gl_FragCoord.xy / resolution.xy;
    float r = 0.5 + 0.5 * sin(time + uv.x * 3.14);
    float g = 0.5 + 0.5 * sin(time + uv.y * 3.14);
    float b = 0.5 + 0.5 * sin(time + uv.x + uv.y);
    gl_FragColor = vec4(r, g, b, 1.0);
  }
`);
animate();


the shader can use the extracted color palette as base tones and mix between them smoothly, adding gentle noise or sine-based waves to create movement.

in short:

grab image colors dynamically

generate gradient or shader background from those colors

blur and animate the background

keep everything reactive so each new image updates the background automatically

the end result should feel fluid — like the image and background are part of the same living surface.